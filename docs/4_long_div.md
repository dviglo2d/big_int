**Главы:**
1) [Основы длинной арифметики](1_basics.md)
2) [Длина неполного частного](2_div_len.md)
3) [Деление путём подбора разрядов](3_brute_force_div.md)
4) [Деление столбиком](4_long_div.md)

----------------------------------------------

# 4. Деление столбиком

Деление уголком позволяет делить числитель покусочно, а значит при проверках перемножаются более короткие числа.

Допустим нам нужно разделить 10512 на 23.
Для простоты будем использовать десятичную СС и обычный порядок цифр.

1\) Инициализация переменных:

```
результат = {} // Пустой массив
кусок = {}
```

2\) При сложении и умножении мы начинали с младших разрядов, а при делении начинаем со старших.
Копируем очередную цифру числителя в кусок:

```
// Для краткости пишем 1234 вместо {1, 2, 3, 4}
кусок = 1 // Дописали 1
```

Дописывание цифры - это то же самое, что и `кусок = кусок * base + цифра`.

3\) Делим кусок на знаменатель (подбором) и получаем очередную цифру результата:

```
разряд = кусок / знаменатель = 1 / 23 = 0
результат = 0 // Ведущие нули потом нужно убрать
```

4\) Что осталось от куска (`кусок = кусок % знаменатель`):

```
кусок = кусок - разряд * знаменатель = 1 - 0 * 23 = 1 // Кусок не поменялся
```

5\) Повторяем алгоритм, начиная с шага 2, пока не кончатся цифры числителя:

```
кусок = 10 // Дописали 0
разряд = кусок / знаменатель = 10 / 23 = 0
результат = 00 // Дописали 0
кусок = кусок - разряд * знаменатель = 10 - 0 * 23 = 10 // Кусок не поменялся

кусок = 105 // Дописали 5
разряд = кусок / знаменатель = 105 / 23 = 4
результат = 004 // Дописали 4
кусок = кусок - разряд * знаменатель = 105 - 4 * 23 = 13

кусок = 131 // Дописали 1
разряд = кусок / знаменатель = 131 / 23 = 5
результат = 0045 // Дописали 5
кусок = кусок - разряд * знаменатель = 131 - 5 * 23 = 16

кусок = 162 // Дописали 2
разряд = кусок / знаменатель = 162 / 23 = 7
результат = 00457 // Дописали 7
кусок = кусок - разряд * знаменатель = 162 - 7 * 23 = 1
```

6\) В итоге кусок содержит остаток от деления:

```
остаток = кусок = 1
результат = 457 // Убрали ведущие нули
```

Релизация: [4_long_div_1.cpp](4_long_div_1.cpp).

## Оптмизируем деление куска на знаменатель

Мы формировали кусок таким образом, чтобы деление `кусок / знаменатель` давало ровно одну цифру результата,
то есть `кусок < знаменатель · base`. Это открывает ряд путей для оптимизации.

Если `кусок < знаменателя`, то `кусок / знаменатель = 0` и оптимизировать тут нечего. Поэтому далее
будем рассматривать ситуацию, когда `кусок ≥ знаменателя`.

### Оптимизация 1

Обратите внимание, что кусок максимум на одну цифру длиннее знаменателя. То есть,
если в знаменателе одна цифра, то кусок состоит из максимум двух цифр,
а значит умещается в регистре процессора. В этом случае можно использовать обычное
процессорное деление и ничего подбирать не нужно.

Релизация: [4_long_div_2.cpp](4_long_div_2.cpp).

### Оптимизация 2

В литературе считается, что `длина куска = длина знаменателя + 1` (если `длина куска = длине знаменателя`,
то к куску дописывается ведущий 0).

Существует теорема, что если поделить две старших цифры куска на старшую цифру знаменателя,
то полученная `примерная_цифра` будет довольно близко к искомой цифре и не меньше неё: `примерная_цифра ≥ цифра`.
Это позволяет при двоичном поиске в качестве правой границы использовать не `base - 1`, а меньшее число.

Но и значительные отклонения тоже бывают. Пример:

```
кусок = 94
знаменатель = 19
примерная_цифра = 09 / 1 = 9
цифра = 94 / 19 = 4
ошибка = примерная_цифра - цифра = 5
```

Пример при base = 10<sup>9</sup>:

```
кусок = 1873'135157604'149223893
знаменатель = 3119'654553545
примерная_цифра = 1873'135157604 / 3119 = 600556318
цифра = 600430312
ошибка = примерная_цифра - цифра = 126006
```

Следует учесть, что иногда `примерная_цифра` может получиться больше `base - 1`, тогда её нужно ограничить сверху.
Пример:

```
кусок = 169
знаменатель = 19
примерная_цифра = 16 / 1 = 16
примерная_цифра = min(примерная_цифра, 9) = 9
цифра = 169/19 = 8
ошибка = примерная_цифра - цифра = 1
```

Релизация: [4_long_div_3.cpp](4_long_div_3.cpp).

### Оптимизация 3

Ещё одна теорема утверждает, что если старшая цифра знаменателя ≥ `base / 2`, то `примерная_цифра`
будет больше искомой цифры максимум на 2, т.е. возможны всего 3 варианта:

1. `цифра = примерная_цифра`
2. `цифра = примерная_цифра - 1`
3. `цифра = примерная_цифра - 2`

Это позволяет отказаться от двоичного поиска и вернуться к перебору цифр, так как потребуется максимум две проверки.

Если старшая цифра знаменателя < `base / 2`, тогда перед делением нужно
умножить числитель и знаменатель на коэффициент, который даст нам подходящий знаменатель.
Это называется нормализацией.
Искомое частное после нормализации дроби не изменится, так как
`(числитель · коэффициент) / (знаменатель · коэффициент) = числитель / знаменатель`,
а вот искомый остаток после всех вычислений нужно разделить на коэффициент.
Так как коэффициент - это одна цифра, то у нас для деления на коэффициент уже есть функция `div_by_digit()`.

Реализация: [4_long_div_4.cpp](4_long_div_4.cpp).

### Оптимизация 4

Предыдущую оптимизацию можно улучшить, дополнительно изучив ещё по одной цифре куска и знаменателя.
Это приведёт к тому, что `примерная_цифра` почти всегда будет совпадать с `искомой_цифрой`.
И лишь с вероятностью `2 / base` `примерная_цифра` будет больше `искомой_цифры` на 1.
То есть чем больше основание СС, тем меньше вероятность промаха.

Реализация: [4_long_div_5.cpp](4_long_div_5.cpp).

Литература:
1. https://ru.wikipedia.org/wiki/Деление_столбиком
2. https://en.wikipedia.org/wiki/Long_division
3. https://ru.wikipedia.org/wiki/Деление_с_остатком
4. https://www.codeproject.com/Articles/1276311/Multiple-Precision-Arithmetic-Division-Algorithm
5. http://algolist.manual.ru/maths/longnum.php
6. https://www.geeksforgeeks.org/divide-large-number-represented-string/
7. [Pope, Stein. Multiple Precision Arithmetic](https://dl.acm.org/doi/10.1145/367487.367499)
8. [Krishnamurthy, Nandi. On the Normalization Requirement of Divisor in Divide-and-Correct Methods](https://dl.acm.org/doi/abs/10.1145/363848.363867)
9. [Дональд Кнут. Искусство программирования. Том 2. Третье издание. Раздел 4.3.1](https://djvu.online/file/AK1GKM4qtVd6r#p=311),
    а также [упражнения](https://djvu.online/file/AK1GKM4qtVd6r#p=323)
    и [ответы на упражнения](https://djvu.online/file/AK1GKM4qtVd6r#p=685)
10. [Кнут на английском](https://www.haio.ir/app/uploads/2022/01/The-art-of-computer-programming.-Vol.2.-Seminumerical-algorithms-by-Knuth-Donald-E-z-lib.org_.pdf#page=285) (перевод на русский — неточный)
11. https://rsdn.org/forum/alg/2355320.hot
12. [Hansen. Multiple-Length Division Revisited: A Tour of the Minefield](https://surface.syr.edu/eecs_techreports/166/)
13. [Brent, Zimmermann. Modern Computer Arithmetic](https://maths-people.anu.edu.au/~brent/pub/pub226.html)
14. [Verma. Implementing Basic Arithmetic for Large Integers: Division](https://mathsanew.com/articles_html/23/implementing_large_integers_division.html)
